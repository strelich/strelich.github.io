{
  "hash": "ae5fa8f15557d0c7b288d56589479223",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Data Visualization with ggplot2\"\ndescription: \"An introduction to data visualization with ggplot2\"\nauthor: \"Jack Strelich\"\ndate: 2024-11-25\ncategories: [R, Data Visualization]\ndraft: false\nformat: \n  html: \n    df-print: paged\nimage: \"index_files/figure-html/fig-plot-captions-1.png\"\n---\n\n\n# Introduction\n\nToday's post is adapted from a workshop I ran as part of my stats fellowship in my PhD program. My goal with this post is to cover the basics of data visualization with ggplot2 (natch), but also to shed a little light on the reasoning behind effective data communication.\n\nIn this post, we'll cover the basics of ggplot2, then explore how to plot distributions and summary statistics, combine different representations of data in a single plot, customize plot appearance, and export plots.\n\n`ggplot2` implements a \"grammar of graphics\" (Wilkinson, 2005), allowing for the specification of plots in terms of individual elements, and the iterative creation of plots (we can layer elements in one by one). At heart, plots in `ggplot2` consist of **data** (variables) mapped to **aesthetics** (e.g., position, color, and shape of plot elements).\n\n\n## Load data set\n\nWe'll be working with a simulated data set today (`data-viz.csv`); you can download it [here](https://github.com/strelich/strelich.github.io/shared-data/data-viz.csv). All the packages we'll need can be loaded via `library(tidyverse)`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load packages\nlibrary(tidyverse) \n\n# Load data\nmain_dat <- read_csv(\"data-viz.csv\") \n\n# Overview of data\nsummary(main_dat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       ID          Condition            Gender             Major          \n Min.   :  1.00   Length:300         Length:300         Length:300        \n 1st Qu.: 75.75   Class :character   Class :character   Class :character  \n Median :150.50   Mode  :character   Mode  :character   Mode  :character  \n Mean   :150.50                                                           \n 3rd Qu.:225.25                                                           \n Max.   :300.00                                                           \n      SES           Anxiety            RT       \n Min.   :1.000   Min.   : 6.00   Min.   :112.0  \n 1st Qu.:2.000   1st Qu.:13.00   1st Qu.:180.8  \n Median :3.000   Median :16.00   Median :201.0  \n Mean   :2.637   Mean   :15.71   Mean   :200.7  \n 3rd Qu.:3.000   3rd Qu.:18.00   3rd Qu.:222.0  \n Max.   :5.000   Max.   :24.00   Max.   :279.0  \n```\n\n\n:::\n\n```{.r .cell-code}\nglimpse(main_dat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 300\nColumns: 7\n$ ID        <dbl> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 1…\n$ Condition <chr> \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", …\n$ Gender    <chr> \"Male\", \"Male\", \"Male\", \"Male\", \"Female\", \"Male\", \"Male\", \"M…\n$ Major     <chr> \"Psyc\", \"Hist\", \"Psyc\", \"Chem\", \"Hist\", \"Hist\", \"Hist\", \"Psy…\n$ SES       <dbl> 4, 3, 4, 1, 1, 1, 3, 3, 2, 2, 3, 2, 1, 1, 3, 5, 3, 2, 2, 1, …\n$ Anxiety   <dbl> 17, 14, 16, 17, 17, 19, 19, 17, 19, 17, 20, 15, 19, 16, 15, …\n$ RT        <dbl> 213, 151, 189, 240, 195, 187, 237, 178, 217, 179, 220, 182, …\n```\n\n\n:::\n:::\n\n\nThe data is from an imaginary psychological experiment; we have three categorical variables (`Condition`, `Major`, and `Gender`) and three continuous variables (`SES` [socio-economic status], `Anxiety`, and `RT` [reaction time]) for each of 300 imaginary participants, each with a unique identifier (`ID`).\n\n# Basics of `ggplot2`\n\nTo create a plot, we first call the `ggplot()` function. The `data` argument specifies the data set, and the `mapping` argument maps specific variables to aesthetics via the `aes()` function. Here, we'll map `Anxiety` to the x-axis and `RT` to the y-axis:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = main_dat, \n       mapping = aes(x = Anxiety, y= RT))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/basic-plot-1.png){width=672}\n:::\n:::\n\n\nNotice that running this code gives us a graph, but no data! We've told `ggplot` *what* data to graph, but not *how*.\n\n## Adding plot elements\n\nHaving mapped variables onto the x-axis and y-axis, we can create a scatterplot by adding points via `geom_point()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# We'll omit argument names (data, mapping) going forward\n# ggplot() assumes the first argument is data and the second is mapping\nggplot(main_dat, aes(x = Anxiety, y= RT)) + geom_point() \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/basic-scatterplot-1.png){width=672}\n:::\n:::\n\n\n`geom_point()` is an example of a `geom`, a geometric representation of data. We'll see a number of different `geom`s later!\n\nNext, we can set the color of the points to be based on `Condition` by mapping it onto color in the original `aes()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(main_dat, aes(x = Anxiety, y = RT, color = Condition)) + \n  geom_point()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/scatterplot-color-1.png){width=672}\n:::\n:::\n\n\nWe can map `Major` to the shape of the points in the same way:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(main_dat, aes(x = Anxiety, y = RT, color = Condition, shape = Major)) + \n  geom_point()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/scatterplot-color-shape-1.png){width=672}\n:::\n:::\n\n\nEach addition to the aesthetic specification maps a new variable onto a new aesthetic of the plot. Also notice that we now get two legends, one for color and one for shape. \n\n## Saving plots\n\nTo save[^saving] a plot for later use (and save ourselves a lot of copy-pasting), we can assign `ggplot()` output to an object:\n\n[^saving]: \"Save\" here means \"keep in memory\", _not_ \"save to disk\"; we'll cover that a little later.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nRT_by_anxiety_cond <- ggplot(main_dat, aes(x = Anxiety, y = RT, \n                                           color = Condition, shape = Major)) + \n  geom_point()\n```\n:::\n\n\nCalling the object then displays the plot:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRT_by_anxiety_cond\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/call-scatterplot-1.png){width=672}\n:::\n:::\n\n\n## Faceting\n\nWe now have four variables (`Anxiety`, `RT`, `Condition`, and `Major`) in one plot -- very efficient, but a little hard to read. One solution is to split the plot into **facets**, giving us a mini-plot for each level of a factor...\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRT_by_anxiety_cond + facet_wrap(~Major) # \"By major\"\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/scatterplot-facet-wrap-1.png){width=672}\n:::\n:::\n\n\n...or for combinations of levels of factors:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRT_by_anxiety_cond + facet_grid(Major~Condition) # \"By major and condition\"\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/scatterplot-facet-grid-1.png){width=672}\n:::\n:::\n\n\nSwitch order of variables in `facet_grid()` to flip arrangement of facets:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRT_by_anxiety_cond + facet_grid(Condition~Major) \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/scatterplot-facet-grid-flipped-1.png){width=672}\n:::\n:::\n\n\nNotice that all of the facets have shared (aligned) axes, allowing us to compare data (e.g., point positions) between facets!\n\n`facet_grid()` always creates rows and columns based on the faceting variable(s) you specify, which makes it useful when you want to facet by two specific variables. In contrast, `facet_wrap()` will wrap the facets into rows and columns, which makes it useful when you want to facet by a single variable that has more than three or so values:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# New plot for this example\nggplot(main_dat, aes(x=Anxiety,y=RT)) + geom_point() + facet_wrap(~SES)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/scatterplot-facet-SES-1.png){width=672}\n:::\n:::\n\n\nNotice how SES levels 4 and 5 wrap around to make a second row!\n\n## Coordinates\n\nWe can also customize the coordinate system used by our plot. Let's force our y-axis includes zero:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# To keep an auto-calculated limit, use NA\nRT_by_anxiety_cond + coord_cartesian(ylim = c(0,NA)) \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/scatterplot-coords-y0-1.png){width=672}\n:::\n:::\n\n\nWe can swap X and Y axes using `coord_flip()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRT_by_anxiety_cond + coord_flip(ylim = c(0,NA)) # y-axis is now horizontal!\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/scatterplot-coords-flip-1.png){width=672}\n:::\n:::\n\n\nOther useful coordinate systems:\n\n- `coord_fixed()` fixes aspect ratio of plot (good if X and Y are in same units)\n- `coord_map()`projects portion of globe onto 2D plane (good for maps!)\n\n## Theme\n\nThemes allow us to change the appearance of the plot as a whole:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRT_by_anxiety_cond + theme_light() # Use light background\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/scatterplot-themes-1.png){width=672}\n:::\n\n```{.r .cell-code}\nRT_by_anxiety_cond + theme_minimal() # Omit bounding boxes\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/scatterplot-themes-2.png){width=672}\n:::\n\n```{.r .cell-code}\nRT_by_anxiety_cond + theme_classic() # More traditional style\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/scatterplot-themes-3.png){width=672}\n:::\n:::\n\n\nWe can tweak the font[^fonts] used in the plot via arguments to the theme function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRT_by_anxiety_cond + theme_classic(base_size = 9, base_family = \"serif\") \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/scatterplot-font-1.png){width=672}\n:::\n:::\n\n\n[^fonts]: Using custom fonts in ggplot2 is [tricky](http://www.cookbook-r.com/Graphs/Fonts/), to say the least. The three options guaranteed to work on any graphic device are `sans` (the default), `serif`, and `mono`; anything else is a roll of the dice. I hope to cover this topic in a little more detail in a future post, since I've spent a good amount of time tearing my hair out over it.\n\nWe can manually customize further by adding an additional `theme()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRT_by_anxiety_cond + \n  theme(legend.position = \"bottom\") # Move legend to bottom\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/scatterplot-custom-theme-1.png){width=672}\n:::\n\n```{.r .cell-code}\nRT_by_anxiety_cond + \n  facet_grid(Condition~Major) + \n  theme(legend.position = \"none\") # Remove unnecessary legends\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/scatterplot-custom-theme-2.png){width=672}\n:::\n:::\n\n\nVirtually every aspect of the plot's appearance can be customized via the `theme()` function, from major/minor axes to tick marks to the axis titles.\n\n\n## Recap\n\nLet's pause and review how to construct a plot with `ggplot()`:\n\n- We start by giving `ggplot()` a **data frame** (here, `main_dat`)\n- Within the `aes()` argument, we map variables to specific **elements** (x and y position, color, and shape)\n- We provide (at least one) **`geom`** to represent the data (here, `geom_point()` to get points)\n- We can **facet** by one (or more) variables to produce multiple plots with shared axes\n- We can specify **coordinate** systems (e.g., `coord_flip()`)\n- **Themes** let us customize overall plot appearance\n\nNext, we'll explore how we can use these tools to visualize different types of data!\n\n# Visualizing Distributions\n\n## Histograms\n\nWe can make histograms with `geom_histogram()`. We don't map anything to the y-axis -- R automatically maps frequency.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(main_dat, aes(x = Anxiety)) + # No Y aesthetic!\n  geom_histogram()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/basic-histogram-1.png){width=672}\n:::\n:::\n\n\nWe can manually set size of bins:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(main_dat, aes(x = Anxiety)) + \n  geom_histogram(binwidth = 2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/histogram-tweak-bins-1.png){width=672}\n:::\n:::\n\n\nWhat if we want to look at the distribution separately for each level of `Condition`? We can map `Condition` onto the fill color of the histogram via the `fill` aesthetic[^fill]:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(main_dat, aes(x = Anxiety, fill = Condition)) +\n  geom_histogram(binwidth = 2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/histogram-by-condition-1.png){width=672}\n:::\n:::\n\n\n[^fill]: For geoms that _don't_ have an \"interior\" (e.g., points and lines), the `color` aesthetic sets the color of the whole geom. For geoms that _do_ have an interior (e.g., histograms and bars), the `fill` aesthetic sets the interior color and the `color` aesthetic sets the outline color. It can be a little tricky to remember -- if specifying one aesthetic doesn't work the way you expect, try specifying the other and see if that has the desired effect.\n\nThis plot's not great -- it's hard to read counts for Control and Treatment 1. Instead, let's try faceting:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(main_dat, aes(x = Anxiety, fill = Condition)) + \n  geom_histogram(binwidth = 2) + \n  facet_wrap(~Condition, ncol = 1) + # Force facets into single column\n  theme(legend.position = \"none\") # Remove superfluous legend\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/histogram-by-condition-faceted-1.png){width=672}\n:::\n:::\n\n\nThis plot makes it much easier to compare distributions between the three groups -- notice that x-axis (`Anxiety`) scores are aligned across all three facets.\n\n## Bar plot of frequencies\n\nFor categorical variables (like `Condition`), we can get frequency as a bar plot using `geom_bar()`. Just like with histograms, we don't map anything to the y-axis; the `geom` automatically calculates the height of the bars (in this case, by counting the number of cases).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(main_dat,aes(x = Gender)) + # No Y aesthetic!\n  geom_bar()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/bar-plot-counts-1.png){width=672}\n:::\n:::\n\n\n# Plotting Summary Statistics\n\nIn both of these examples, R calculated a summary statistic (number of cases) automatically. But what if we want to plot a different summary statistic?\n\n## Background\n\nUnder the hood, all geometric elements have a `stat` that determines how the data translates into the properties of the `geom`:\n\n- `geom_point()`: *x* and *y* coordinates of points come directly from numeric values (`identity`)\n- `geom_histogram()`: height of bin comes from number of values in bin (`count`)\n- `geom_bar()`: height of bar comes from number of values in category (`count`)\n\n`geom_point()` creates one object for each data point, while `geom_histogram()` and `geom_bar()` use a built-in **summary statistic**. Sometimes, we'll want to tweak this process (e.g., if we want to plot a different summary statistic):\n\n- Barplot: height of bar from the mean of each group\n- Pointrange: height of point from mean of group, width of range from variability of group\n\nThere are two possible approaches here:\n  \n- Calculate summary statistics for each group, then plot these values\n  - `data %>% group_by() %>% summarize() %>% ggplot()`\n- Have ggplot generate specific summary statistics for us\n  - `data %>% ggplot() + stat_summary()`\n\nToday, we'll focus on the second approach!\n    \n## Getting summary statistics on the fly\n\nLet's get a bar plot in which the bar heights represent group means (rather than frequencies):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(main_dat, aes(x = Condition, y = Anxiety)) + \n  stat_summary(fun = \"mean\", geom = \"bar\") # Get the mean, represent via bars\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/bar-plot-means-1.png){width=672}\n:::\n:::\n\n\nIf we want to get fancy, we can specify summary functions that return multiple values for each group, and geoms that use all these values:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(main_dat, aes(x = Condition, y = Anxiety)) + \n  stat_summary(fun.data = \"mean_cl_normal\", geom = \"pointrange\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/pointrange-means-1.png){width=672}\n:::\n:::\n\n\nWe use `fun.data` because the function we've specified (`mean_cl_normal`) returns a data frame consisting of the mean as well as the upper and lower bounds of the 95% confidence interval.\n\n## 2 Multiple 2 Geoms\n\nWe can have more than one geom in the same plot! Let's add a line:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(main_dat, aes(x = Condition, y = Anxiety)) + \n  # Plot means as line, all one group\n  stat_summary(fun = \"mean\", geom = \"line\", group = 1) +\n  # Plot means/CIs as pointranges\n  stat_summary(fun.data = \"mean_cl_normal\", geom = \"pointrange\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/multiple-geoms-1.png){width=672}\n:::\n:::\n\n\nNotice the line uses `fun` (instead of `fun.data`) because it represents a single summary statistic (the mean).\n\nWe can combine summary statistics (our pointrange and lines) with raw data (i.e., individual data points):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(main_dat, aes(x = Condition, y = Anxiety)) + \n  stat_summary(fun.data = \"mean_cl_normal\", geom = \"pointrange\") + \n  stat_summary(fun = \"mean\", geom = \"line\", group = 1) +\n  geom_point() # Add in raw data\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/summaries-plus-raw-data-1.png){width=672}\n:::\n:::\n\n\nTo avoid *overplotting* (data points directly on top of each other), we can make the points partially transparent:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(main_dat, aes(x = Condition, y = Anxiety)) + \n  stat_summary(fun.data = \"mean_cl_normal\", geom = \"pointrange\") + \n  stat_summary(fun = \"mean\", geom = \"line\", group = 1) + \n  geom_point(alpha = .1) # 1 = opaque, 0 = fully transparent\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/summaries-plus-raw-data-transparent-1.png){width=672}\n:::\n:::\n\n\nWe can also use a different geom to summarize the data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(main_dat, aes(x = Condition, y = Anxiety)) + \n  geom_violin() + # Put first so pointranges/lines are drawn on top\n  stat_summary(fun.data = \"mean_cl_normal\", geom = \"pointrange\") + \n  stat_summary(fun = \"mean\", geom = \"line\", group = 1)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/summaries-plus-violin-1.png){width=672}\n:::\n:::\n\n\n## Multiple pointranges, multiple lines\n\nLet's break things down by major as well as condition!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmain_dat %>% \n  ggplot(aes(x = Condition, y = Anxiety, \n             color = Major, group = Major)) + # Specify how to group!\n  stat_summary(fun.data = \"mean_cl_normal\", geom = \"pointrange\") + \n  stat_summary(fun = \"mean\", geom = \"line\") + \n  geom_point(alpha = .1)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/summaries-by-condition-major-1.png){width=672}\n:::\n:::\n\n\nTo make things easier to read, let's *dodge* the geoms for each group (i.e., shift them slightly left/right so they're not stacked atop each other):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmain_dat %>% \n  ggplot(aes(x = Condition, y = Anxiety, color = Major, group = Major)) + \n  stat_summary(fun.data = \"mean_cl_normal\", \n               geom = \"pointrange\", \n               position = position_dodge(width = .5)) + \n  stat_summary(fun = \"mean\", \n               geom = \"line\",\n               position = position_dodge(width = .5)) +\n  geom_point(alpha = .1, position = position_dodge(width = .5))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/summaries-by-condition-major-dodged-1.png){width=672}\n:::\n:::\n\n\nNote that we need to specify dodge for each geom to keep things aligned!\n\nLet's save this plot for later use:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nAnxiety_by_cond_major <- main_dat %>% \n  ggplot(aes(x = Condition, y = Anxiety, color = Major, group = Major)) + \n  stat_summary(fun.data = \"mean_cl_normal\", \n               geom = \"pointrange\", \n               position = position_dodge(width = .5)) + \n  stat_summary(fun = \"mean\", \n               geom = \"line\",\n               position = position_dodge(width = .5)) +\n  geom_point(alpha = .1, position = position_dodge(width = .5))\n```\n:::\n\n\nNotice how we were able to build this (fairly complex) plot incrementally: we started by mapping `Condition` and `Anxiety` to the x and y axes, selected appropriate geoms to display our data (both summary statistics via `stat_summary()` and raw values via `geom_point()`), added another variable (`Major`) mapped onto color, and finally tweaked the geoms' position to avoid overplotting. This process aligns nicely with how I tend to approach data visualization: I start by thinking about _what_ variables I want to plot, then figure out _how_ to display them via reckless experimentation. \n\n# Customizing Plot Appearance\n\nTo wrap things up, let's look at some different ways of tweaking aspects of a plot such as axis labels and titles.\n\n## Changing labels\n\nWe can set labels within `scale_*()` functions, or by using the convenience function `labs()`. Let's try this with our earlier scatterplot:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRT_by_anxiety_cond + # Back to our scatterplot!\n  labs(title = \"Mean reaction time by anxiety score, condition, and major\", \n       subtitle = \"Check out my awesome subtitle!\",\n       caption = \"Can note exclusion criteria, define error bars, etc.\",\n       x = \"Anxiety score\", # List of scales and names\n       y = \"Mean reaction time (ms)\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-labs-1.png){width=672}\n:::\n:::\n\n\nNote that all of the labels display within the plot area, and are distinct from figure captions that may be generated by (e.g.) RMarkdown or Quarto. In some contexts, it may be helpful to put as much information as possible in the plot itself (e.g., for a presentation or conference poster), while in other contexts this information may be displayed in the figure caption instead (e.g., a journal article). Here's what this same figure might look like if we took the second approach:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRT_by_anxiety_cond + \n  labs(x = \"Anxiety score\", # List of scales and names\n       y = \"Mean reaction time (ms)\")\n```\n\n::: {.cell-output-display}\n![Mean reaction time by anxiety score, condition, and major. Check out my awesome subtitle! Here's some information about exclusion criteria, error bars, etc.](index_files/figure-html/fig-plot-captions-1.png){#fig-plot-captions width=672}\n:::\n:::\n\n\n\n## Customizing continuous axes\n\nWe can add arguments to `scale_*()` functions to customize the upper/lower bounds, and to determine where the breaks fall:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRT_by_anxiety_cond +\n  scale_y_continuous(name = \"Mean reaction time (ms)\", # Another way to label!\n                     limits = c(0,300), # Upper and lower bounds\n                     breaks = 0:6*50)  # Should give vector of break points\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/tweak-scales-1.png){width=672}\n:::\n:::\n\n\nIf your limits clip some of your data, you'll get a warning:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRT_by_anxiety_cond +\n  scale_y_continuous(name = \"Mean reaction time (ms)\",\n                     limits = c(0,200), # Clips off upper end of data range\n                     breaks = 0:6*50)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 151 rows containing missing values or values outside the scale range\n(`geom_point()`).\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/tweak-scales-clip-data-1.png){width=672}\n:::\n:::\n\n\nIf you are calculating summary statistics via `stat_summary()`, data that gets clipped off won't be included in summary statistics, which can skew results. It's a good idea to set the \"window\" via `coord` instead:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRT_by_anxiety_cond + \n  coord_cartesian(ylim = c(0,200))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/tweak-coords-1.png){width=672}\n:::\n:::\n\n\n## Customizing discrete axes\n\nWe can manually relabel levels of our discrete (categorical) x-axis. Let's try on our pointrange plot:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nAnxiety_by_cond_major + # Our pointrange plot\n  scale_x_discrete(labels = c(\"0mg\", \"500mg\", \"1000mg\")) # Applied in order\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/tweak-discrete-axes-1.png){width=672}\n:::\n:::\n\n\nIn general, to relabel levels, tweak the scale that produced them. Here, for our scatterplot, we'll relabel `Condition` (mapped onto color) and `Major` (mapped onto shape):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRT_by_anxiety_cond + # Our scatterplot\n  scale_color_discrete(labels = c(\"0mg\", \"500mg\", \"1000mg\")) +\n  scale_shape_discrete(labels = c(\"Chemistry\",\"History\",\"Psychology\"))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/tweak-multiple-axes-1.png){width=672}\n:::\n:::\n\n\n## Adjusting colors\n\nWe can change the palettes R uses for colors. Let's practice with a brand-new plot:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create bar plot of gender frequency\nGender_plot <- ggplot(main_dat, aes(x = Gender, fill = Gender)) + \n  geom_bar()\n\n# Default palette\nGender_plot\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/gender-plots-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# Greyscale\nGender_plot + scale_fill_grey()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/gender-plots-2.png){width=672}\n:::\n\n```{.r .cell-code}\n# Brewer\nGender_plot + scale_fill_brewer(type = \"qual\", # Qualitative palettes\n                                palette = \"Set2\") # Specific palette\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/gender-plots-3.png){width=672}\n:::\n:::\n\n\nWe can also manually specify colors via `scale_fill_manual()`, either by name:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nGender_plot + \n  scale_fill_manual(values =c(\"darkorange\", \"dodgerblue\", \"green\", \"purple\"))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/manual-color-scale-1.png){width=672}\n:::\n:::\n\n\nOr by hex code (useful to match existing palettes such as school or corporate color schemes):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nGender_plot +\n  scale_fill_manual(values =c(\"#003660\", \"#FEBC11\", \"#043927\", \"#c4b581\"))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/hex-colors-1.png){width=672}\n:::\n:::\n\n\nFor ordinal variables (like SES), might make sense to use a sequential palette:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(main_dat, aes(x = SES, fill = factor(SES))) + # Make R treat as factor\n  geom_bar() +\n  scale_fill_brewer(type = \"seq\") # Sequential palette\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/ordinal-colors-1.png){width=672}\n:::\n:::\n\n\nIf a factor is ordered, ggplot automatically uses `scale_viridis` (an excellent sequential palette):\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Distribution of SES\nggplot(main_dat, aes(x = SES, fill = ordered(SES))) + \n  geom_bar()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/scale-viridis-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# Distribution of SES by condition\nggplot(main_dat, aes(x = Condition, fill = ordered(SES))) +\n  geom_bar()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/scale-viridis-2.png){width=672}\n:::\n:::\n\n\nNotice that for all of these examples except the last, color is just for visual appeal; it doesn't add information to the plot beyond what's already communicated by the bars themselves. When color _does_ convey information, it's important to consider accessibility (e.g., whether the plot can still convey information effectively to viewers with colorblindness). Some options include using another aesthetic as a fallback (e.g., mapping the variable onto shape as well as color), faceting the plot, using a colorblind-friendly palette (such as `scale_viridis`)[^ADA].\n\n[^ADA]: Disclaimer: I am not an expert in accessibility, and cannot guarantee that these tips will make plots fully or even partially compliant with regulation regarding accessibility (e.g., the [ADA](https://www.ada.gov/resources/web-guidance/)). Please don't sue me!\n\n<!-- See the [Cookbook for R](http://www.cookbook-r.com/Graphs/Colors_(ggplot2)/) for more info! -->\n\n# Exporting plots\n\nFinally, let's talk about exporting plots (i.e., saving them to disk). This can be done via RStudio's menus (Plots tab $\\rightarrow$ Export $\\rightarrow$ Save as Image...), but I prefer to export plots programmatically via the `ggsave()` function, since I can save the code in a script and easily re-run later (for example, in case I realize I need the plot to be a half-inch wider, or a PNG instead of a JPEG).\n\nLet's see an example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggsave(plot = RT_by_anxiety_cond, # Pick which plot to save\n       filename = \"Example.png\", # Extension determines file type (here, PNG)\n       width = 5, # Measurements are in inches by default\n       height = 4) \n```\n:::\n\n\nSome tips to make this process as smooth as possible:\n\n- Figure out how big the final plot needs to be.\n- Save it at that size, rather than scaling after the fact!\n- Change font size (if necessary) via `base_size` argument to `theme()`\n- Use vector graphics (e.g., `.svg`, `.pdf`) whenever possible to avoid pixelation!\n\n# Conclusion\n\nWe've covered a lot of ground in this post! Let's finish by thinking about the big picture: how do we go from an idea to a finished visualization?\n\n1. Start by thinking about how you want to map specific _variables_ to specific aesethetic _elements_ of a plot\n2. Think critically about trade-off between _density_ (number of variables in single plot) and _legibility_\n    - Facets? Multiple plots?\n    - Summary stats (boxplot, violin plot, pointrange) instead of raw data?\n3. Tweak scales as needed (x/y limits, category labels, colors)\n4. Customize theme as desired\n5. Add information to orient viewer via titles, subtitles, and captions. \n\n## More `ggplot2` resources\n\n- [Official `ggplot2` reference](http://ggplot2.tidyverse.org/index.html): First stop for specifics of ggplot2 functions!\n- [*R Graphics Cookbook (2e)*](https://r-graphics.org/): Great for anytime you ask yourself \"How the heck do I do X\"?\n- [*ggplot2: elegant graphics for data analysis*](https://ggplot2-book.org/index.html): For when you're ready to go deeper!\n- [*Fundamentals of Data Visualization*](https://clauswilke.com/dataviz/): For big-picture questions about data visualization and communication best practices!\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}