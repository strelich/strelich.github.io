[
  {
    "objectID": "posts.html",
    "href": "posts.html",
    "title": "Posts",
    "section": "",
    "text": "Data Visualization with ggplot2\n\n\n\n\n\n\nR\n\n\nData Visualization\n\n\n\nAn introduction to data visualization with ggplot2\n\n\n\n\n\nNov 25, 2024\n\n\nJack Strelich\n\n\n\n\n\n\n\n\n\n\n\n\nNYC Crash Data\n\n\n\n\n\n\nR\n\n\nData Cleaning\n\n\nData Visualization\n\n\nMapping\n\n\n\nExploring a data set of motor vehicle crashes in New York City\n\n\n\n\n\nMay 6, 2024\n\n\nJack Strelich\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome",
    "section": "",
    "text": "I’m Jack Strelich, and this is my website! I blog about data wrangling, analysis, and visualization."
  },
  {
    "objectID": "index.html#recent-posts",
    "href": "index.html#recent-posts",
    "title": "Welcome",
    "section": "Recent Posts",
    "text": "Recent Posts\n\n\n\n\n\n\n\n\n\n\nData Visualization with ggplot2\n\n\nAn introduction to data visualization with ggplot2\n\n\n\nJack Strelich\n\n\nNov 25, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNYC Crash Data\n\n\nExploring a data set of motor vehicle crashes in New York City\n\n\n\nJack Strelich\n\n\nMay 6, 2024\n\n\n\n\n\n\n\n\nNo matching items\n\n\n See all"
  },
  {
    "objectID": "posts/2024-05-04-NYC-Crashes/index.html",
    "href": "posts/2024-05-04-NYC-Crashes/index.html",
    "title": "NYC Crash Data",
    "section": "",
    "text": "In this post, I’ll explore a data set of motor vehicle crashes in New York City obtained via data.gov. This data set interested me for two reasons. First, it’s quite comprehensive, covering all crashes resulting in injury and/or over $1000 in damage since mid-2012. Second, it’s messy in a way that’s very representative of real-world data (and very hard to replicate with more “shrink-wrapped” data sets).\nMy goals for this analysis were to perform some basic data cleaning, get some insights from the data, and practice a type of visualization I don’t get to use very often in my day job: the choropleth map!\nTo start, we’ll load the packages we need:\n\n# Load packages\n## Handling dates\nlibrary(lubridate)\n\n## Mapping\nlibrary(sf)\nlibrary(nycgeo)\n\n## And starring...\nlibrary(tidyverse)\n\n# Set theme for plots\ntheme_set(theme_minimal())\n\nNow we’ll read in the data. Because the CSV is so large (~437 Mb), I decided to read it directly via the URL, rather than downloading and reading the file1. Once the data is loaded, we’ll tweak the column names for readability (converting to sentence case and replacing spaces with underscores), read the Crash_date column via lubridate::as_date(), and change the names of the columns containing vehicle type codes to be consistent with other column names. We’ll also filter the data to look only at crashes in 2023, to avoid using too much memory2.\n\n# Load crash data (https://data.cityofnewyork.us/api/views/h9gi-nx95/rows.csv)\ncrash_url &lt;- \"https://data.cityofnewyork.us/api/views/h9gi-nx95/rows.csv\"\n\n# Load data (takes a minute!)\ncrash_dat &lt;- vroom::vroom(file = crash_url, # Read from URL\n                          guess_max = 10^3,\n                          .name_repair = ~str_replace_all(str_to_sentence(.x), \n                                                          pattern = \" \", \n                                                          replacement = \"_\")) %&gt;%  \n  mutate(Crash_date= as_date(Crash_date, format = \"%m/%d/%Y\")) %&gt;% \n  filter(year(Crash_date) == 2023) %&gt;% # Only 2023 data\n  rename_with(\\(var) str_replace_all(var, \n                                     pattern = \"Vehicle_type_code\", \n                                     replacement = \"Type_code_vehicle\"))\n\nRows: 2084770 Columns: 29\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (16): Crash_date, Borough, Location, On_street_name, Cross_street_name,...\ndbl  (12): Zip_code, Latitude, Longitude, Number_of_persons_injured, Number_...\ntime  (1): Crash_time\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message."
  },
  {
    "objectID": "posts/2024-05-04-NYC-Crashes/index.html#time-and-date",
    "href": "posts/2024-05-04-NYC-Crashes/index.html#time-and-date",
    "title": "NYC Crash Data",
    "section": "Time and date",
    "text": "Time and date\nFirst, let’s look at incidents by month:\n\nggplot(crash_dat, aes(x = month(Crash_date, label = TRUE))) + \n  geom_bar() +\n  labs(x = \"Month\", y = \"Incidents\")\n\n\n\n\n\n\n\nFigure 1: Incidents by date\n\n\n\n\n\nNo obvious differences by month/season! Next, let’s consider crash times. Looking at raw crash time data, there seems to be an unusually high number of crashes at exactly midnight (00:00):\n\ncount(crash_dat, Crash_time,sort = TRUE) %&gt;% head(n=10)\n\n\n  \n\n\n\nIn fact, we see almost twice as many crashes reported at midnight as at 5pm! This makes me suspect that in at least some cases a crash time of 00:00 represents missing data; for the purposes of this graph, we’ll exclude them.\nNow to see whether the time that incidents occurred varied by month. To help us compare months, we’ll use a ridgeline plot3, via ggridges::geom_density_ridges():\n\ncrash_dat %&gt;% \n  filter(Crash_time &gt; 0) %&gt;% \n  mutate(Crash_month = month(Crash_date, label = TRUE)) %&gt;% \n  ggplot(aes(x=Crash_time, \n             color=Crash_month,\n             fill=Crash_month,\n             y = fct_rev(Crash_month))) + \n  ggridges::geom_density_ridges(alpha = 0.4,\n                                quantile_lines = TRUE,\n                                quantiles = 2) +\n  scale_color_viridis_d() +\n  scale_x_time(breaks = (0:6)*14400) +\n  labs(x = \"Time of day\", y = \"Month\", \n       caption = \"Vertical lines represent median.\") + \n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\nFigure 2: Incidents by month and time of day\n\n\n\n\n\nCrashes by time of day look fairly consistent across months; notice that the median of each distribution is around 2pm. Additionally, we can see peaks in the number of incidents between 8-9am and between 5-6pm (representing rush hour, I’m assuming)."
  },
  {
    "objectID": "posts/2024-05-04-NYC-Crashes/index.html#injuries-and-fatalities",
    "href": "posts/2024-05-04-NYC-Crashes/index.html#injuries-and-fatalities",
    "title": "NYC Crash Data",
    "section": "Injuries and fatalities",
    "text": "Injuries and fatalities\nTo explore crash outcomes, we’ll use pivot_longer() to make a data frame with multiple rows per crash, each row representing the number of motorists, cyclists, or pedestrians (Type) who were injured or killed (Outcome) in that crash.\n\noutcomes_by_crash &lt;- crash_dat %&gt;% \n  select(Collision_id, \n         starts_with(\"Crash\"), # Keep date and time\n         starts_with(\"Number_of_\")) %&gt;%\n  pivot_longer(cols = starts_with(\"Number_of_\"), \n               names_prefix = \"Number_of_\", # Clean up col names\n               names_sep = \"\\\\_\", # Split at underscore\n               names_to = c(\"Type\",\"Outcome\")) %&gt;% \n  mutate(Crash_month = month(Crash_date, label = TRUE),\n         Type = str_to_title(Type),\n         Outcome = str_to_title(Outcome))\n\n# Check our work\nhead(outcomes_by_crash, n = 10)\n\n\n  \n\n\n\nNow we can plot total injuries/fatalities for motorists, cyclists, and pedestrians by month. Because fatalities are (thankfully) far rarer than injuries, we’ll use the scales = \"free_y\" argument to facet_wrap() to let the two halves of the plot use different y-axis limits. We’ll also use fct_reorder() to make sure the ordering of categories in the legend matches the ordering of the categories in the graph itself.\n\noutcomes_by_crash %&gt;% \n  filter(Type != \"Persons\") %&gt;% \n  mutate(Type = fct_reorder(Type, value, sum, .desc = T)) %&gt;% \n  ggplot(aes(x = Crash_month, \n             y = value, \n             color = Type,\n             group = Type)) + \n  stat_summary(geom=\"line\", fun = \"sum\") +\n  stat_summary(geom=\"point\", fun = \"sum\") + \n  facet_wrap(~Outcome,\n             scales = \"free_y\",\n             nrow = 2) + \n  labs(y = \"Number of persons\", x= \"Month\")\n\n\n\n\n\n\n\nFigure 3: Injuries and fatalities by month\n\n\n\n\n\nInterestingly, injuries and fatalities for motorists seem to be highest in summer, while injuries and fatalities for pedestrians are lower during these months."
  },
  {
    "objectID": "posts/2024-05-04-NYC-Crashes/index.html#vehicles",
    "href": "posts/2024-05-04-NYC-Crashes/index.html#vehicles",
    "title": "NYC Crash Data",
    "section": "Vehicles",
    "text": "Vehicles\nNext, let’s explore the contributing factors and types of vehicles involved.\n\nCleaning\nWe’ll restructure the data such that each row represents one vehicle, rather than one incident!\n\nvehicle_dat &lt;- crash_dat %&gt;% \n  select(Collision_id, starts_with(c(\"Contributing_factor\",\"Type_code\"))) %&gt;% \n  pivot_longer(-Collision_id, \n               names_sep = \"_vehicle_\", \n               names_to = c(\".value\",\"Vehicle\")) %&gt;% \n  drop_na() %&gt;% \n  mutate(Vehicle = as.factor(as.numeric(Vehicle)))\n\nNow we can look at the different vehicle type codes and contributing factors that occur in the data:\n\ncount(vehicle_dat, Type_code, sort = TRUE)\ncount(vehicle_dat, Contributing_factor, sort = TRUE)\n\n\n\nTable 1: Incidents by vehicle type and contributing factor (raw)\n\n\n\n\n  \n\n\n\n\n  \n\n\n\n\n\n\nThere are a lot of categories in here, and many of them appear to overlap (e.g., “Motorcycle” and “Motorbike”). To clean up a bit, we’ll change all Type_code entries to sentence case, then manually consolidate some levels:\n\nvehicle_dat &lt;- vehicle_dat %&gt;% \n  mutate(Type_code = str_to_sentence(Type_code),\n         Type_code = case_when( # checks a series of conditionals\n           str_detect(Type_code, \n                      coll(\"wagon\", ignore_case = TRUE)) ~ \"SUV/station wagon\",\n           str_detect(Type_code, \n                      coll(\"sedan\",ignore_case = TRUE)) ~ \"Sedan\",\n           .default = Type_code),\n         Type_code = case_match( # Replaces (vectors of) matches, OLD ~ NEW\n           Type_code,\n           \"Bicycle\" ~ \"Bike\",\n           \"Motorbike\" ~ \"Motorcycle\",\n           c(\"Ambul\",\"Ambu\",\"Amb\") ~ \"Ambulance\",\n           c(\"Unkno\",\"Unk\") ~ \"Unknown\",\n           c(\"Fire\",\"Fdny\",\"Firetruck\",\n             \"Firet\",\"Fdny truck\",\"Fdny fire\") ~ \"Fire truck\",\n           \"E-sco\" ~ \"E-scooter\",\n           \"E-bik\" ~ \"E-bike\",\n           .default = Type_code) %&gt;% \n           fct_lump_prop(0.005), # Lump codes occurring less than 0.5% \n         Contributing_factor = fct_lump_prop(\n           str_to_sentence(Contributing_factor), \n           0.005)) # same for contributing factor\n\nNow let’s check our work:\n\n(crashes_by_type &lt;- count(vehicle_dat, Type_code, \n                          sort = TRUE, name = \"Crashes\"))\n(crashes_by_factor &lt;- count(vehicle_dat, Contributing_factor, \n                            sort = TRUE, name = \"Crashes\"))\n\n\n\nTable 2: Incidents by vehicle type and contributing factor\n\n\n\n\n  \n\n\n\n\n  \n\n\n\n\n\n\nIt’s not perfect, and a subject matter expert could probably identify more types/factors that could be combined, but it should be workable for our purposes.\n\n\nExploring\n\nWhat types of vehicles were involved in crashes?\n\nggplot(crashes_by_type, aes(x = fct_rev(fct_inorder(Type_code)), y = Crashes)) + \n  geom_col() + coord_flip() +\n  labs(x = \"Vehicle type\")\n\n\n\n\n\n\n\nFigure 4: Incidents by vehicle type\n\n\n\n\n\nWithout knowing more about how common different types of vehicles are in NYC, we can’t make strong inferences from this data; i.e., the prevalence of sedans, SUVs, and station wagons in the crash data likely reflects the prevalence of these vehicles on the road, period. If we wanted to explore whether certain vehicle types are disproportionately likely to be involved in crashes, we’d need to know not just how many of each vehicle type are present in the city, but also how many hours each vehicle type is in motion on average (since, for example, buses and box trucks probably spend more of their time driving than private passenger vehicles, even if there are more of the latter).\n\n\nWhat contributing factors were involved in crashes?\n\ncrashes_by_factor %&gt;% \n  filter(Contributing_factor != \"Unspecified\") %&gt;% # Ignore missing data\n  ggplot(aes(x = fct_rev(fct_inorder(Contributing_factor)), y = Crashes)) + \n  geom_col() + coord_flip() +\n  labs(x = \"Contributing factor\")\n\n\n\n\n\n\n\nFigure 5: Incidents by contributing factor\n\n\n\n\n\nHere, we can draw more inferences from the data alone. Distracted driving seems to be a clear issue, as well as following too closely and failing to yield.\n\n\nHow many vehicles were involved per crash?\nWe can also examine how many vehicles were involved per crash, and plot the distribution:\n\ncount(vehicle_dat, Collision_id, name = \"Vehicles\") %&gt;% # Count vehicles per collision\n  count(Vehicles, name = \"Crashes\") %&gt;% # Count collisions for each number of vehicles\n  mutate(Proportion = Crashes/sum(Crashes),\n         Label = paste0(scales::percent(Proportion),\"\\n(n=\",Crashes,\")\")) %&gt;% \n  ggplot(aes(x = Vehicles, y = Crashes, label = Label)) + \n  geom_col() + labs(x = \"Number of vehicles involved\") +\n  geom_text(nudge_y = 3000, size = 3)\n\n\n\n\n\n\n\nFigure 6: Incidents by number of vehicles involved\n\n\n\n\n\nPerhaps unsurprisingly, the majority of crashes involved two vehicles; crashes involving three or more vehicles were relatively rare (&lt;10% of crashes)."
  },
  {
    "objectID": "posts/2024-05-04-NYC-Crashes/index.html#mapping",
    "href": "posts/2024-05-04-NYC-Crashes/index.html#mapping",
    "title": "NYC Crash Data",
    "section": "Mapping",
    "text": "Mapping\nFinally, let’s map the data! We’ll begin by filtering out crashes missing location data, or with location (0,0):\n\ncrash_map_dat &lt;- filter(crash_dat, Latitude != 0, Longitude != 0)\n\nThe easiest way to check for outliers is simply to plot the data:\n\nggplot(crash_map_dat, aes(x=Longitude, y=Latitude)) + \n  geom_point(size=0.05, alpha = 0.5) # Small/transparent to handle overplotting\n\n\n\n\n\n\n\nFigure 7: Crash locations\n\n\n\n\n\nThe projection is a little wonky, but we can see the map taking shape. There are enough data points in our data set to make individual streets!\n\nIndividual crashes\nWe can improve our map by incorporating actual map data for New York City. Fortunately, most of the heavy lifting has already been done for us by the nycgeo package! Among other things, this package can split the geography up according to different types of administrative boundaries, from boroughs all the way down to invidual census tracts.\n\n# Load NYC map data (https://nycgeo.mattherman.info/index.html)\nmap_dat &lt;- nyc_boundaries(geography = \"tract\") # Split into census tracts\n\n# Add simple features (sf) to our data set\ncrash_map_dat &lt;- crash_map_dat %&gt;% \n  st_as_sf(coords = c(\"Longitude\",\"Latitude\"), \n           crs=4326,\n           stringsAsFactors = FALSE)\n\nWe can now overlay individual crashes as points on a map of census tracts:\n\nggplot(data = crash_map_dat) + \n  geom_sf(data = map_dat, mapping = NULL) +\n  geom_sf(size = 0.025, alpha = 0.25, color = \"red\") + \n  theme_void()\n\nold-style crs object detected; please recreate object with a recent sf::st_crs()\n\n\n\n\n\n\n\n\nFigure 8: Crash locations\n\n\n\n\n\nPlotting crashes as individual points is useful for identifying where crashes occurred, but things get muddled by the sheer number of data points, especially where the data get dense (e.g., basically all of Manhattan).\n\n\nChoropleth map\nThe solution is to aggregate the data by dividing the map into subsections and coloring them based on the number of crashes. We’ll define the subsections based on census tracts, thus making a choropleth map!\nWe’ll also need a way to identify which tract each crash occurred in, since our data only includes the lat/lon of the crash. Fortunately, nyc_point_poly() will do just this!\n\ncrash_map_dat_tract &lt;- nyc_point_poly(crash_map_dat, \"tract\") %&gt;% \n  st_set_geometry(NULL)\n\nold-style crs object detected; please recreate object with a recent sf::st_crs()\n\n\nTrasnsforming points to EPSG 2263\n\n\nold-style crs object detected; please recreate object with a recent sf::st_crs()\n\ncrashes_by_tract &lt;- crash_map_dat_tract %&gt;%\n  count(tract_id, name = \"Crashes\", sort = TRUE)\n\n\nhead(crashes_by_tract, n=10)\n\n\n\nTable 3: Crashes per tract\n\n\n\n\n  \n\n\n\n\n\n\n\nNow we’ll join this with our map data and plot:\n\nleft_join(map_dat,crashes_by_tract) %&gt;% \n  ggplot() + \n  geom_sf(aes(fill = Crashes)) +\n  scale_fill_viridis_c(option = \"A\") +\n  coord_sf() +\n  theme_void() + \n  theme(legend.position = c(0.2,0.815)) # Position legend in blank area of plot\n\nJoining with `by = join_by(tract_id)`\nold-style crs object detected; please recreate object with a recent\nsf::st_crs()\n\n\n\n\n\n\n\n\nFigure 9: Crashes by census tract\n\n\n\n\n\nWe can use a similar approach to plot other variables by tract. Let’s look at the total number of injuries reported per tract:\n\ninjuries_by_tract &lt;- crash_map_dat_tract %&gt;% \n  group_by(tract_id) %&gt;% \n  summarise(Injuries =sum(Number_of_persons_injured)) %&gt;% \n  ungroup()\n\nhead(injuries_by_tract, n=10)\n\n\n  \n\n\n\n\nleft_join(map_dat,injuries_by_tract) %&gt;% \n  ggplot() + \n  geom_sf(aes(fill = Injuries)) +\n  scale_fill_viridis_c(option = \"A\") +\n  coord_sf() +\n  theme_void() + \n  theme(legend.position = c(0.2,0.815)) # Position legend in blank area of plot\n\nJoining with `by = join_by(tract_id)`\nold-style crs object detected; please recreate object with a recent\nsf::st_crs()\n\n\n\n\n\n\n\n\nFigure 10: Injuries by census tract\n\n\n\n\n\n\n\nHeatmap\nFor comparison, we can also make a heatmap. Same basic idea as the choropleth map (i.e., colors represent number of crashes per area), but the areas are formed by dividing the geography up into regular polygons, rather than using real-world divisions like census tracts.\n\nggplot() + \n  geom_sf(data = map_dat, mapping = NULL) +\n  geom_hex(data = filter(crash_dat, Latitude != 0, Longitude != 0), \n           aes(x=Longitude,y=Latitude),\n           binwidth=0.005) +\n  coord_sf(crs = 4326) +\n  scale_fill_viridis_c(option = \"A\") +\n  theme_void()+\n  theme(legend.position = c(0.2,0.815))\n\nold-style crs object detected; please recreate object with a recent sf::st_crs()\n\n\n\n\n\n\n\n\nFigure 11: Crashes by location (heatmap)\n\n\n\n\n\nPersonally, I like the choropleth map better; it’s easier to see how the distribution of crashes maps onto the actual geography of the city.\n\n\nCrashes by street and tract\nIn both of our choropleth maps, we can see a couple of tracts with high rates of crashes relative to the surrounding areas (e.g., the long tract between Brooklyn and Queens that seems to correspond to Flushing Meadows Corona Park). I’m guessing that some of these high rates of crashes may be due to freeways and expressways running through the tracts in question. Conveniently, the data set includes the names of the street on which each crash occurred! Let’s look at the street with the most crashes in the top 20 tracts by crashes:\n\ncrash_map_dat_tract %&gt;%\n  count(tract_id, On_street_name, name = \"Crashes\", sort = TRUE) %&gt;% \n  drop_na(On_street_name) %&gt;% \n  filter(tract_id %in% head(crashes_by_tract$tract_id,20)) %&gt;% # Top 20 tracts\n  slice_max(order_by = Crashes, n=1, by = tract_id) # Street w/ most crashes\n\n\n\nTable 4: Street with most crashes per tract\n\n\n\n\n  \n\n\n\n\n\n\nAs expected, in the tracts with the most crashes, the street with the most crashes tends to be a parkway or expressway.\nWhile we’re at it, let’s look at the top 50 streets for crashes citywide. We’ll use the full data set (crash_dat) to include cases where the street was recorded but the latitude/longitude were not.\n\ncrash_dat %&gt;% \n  drop_na(On_street_name) %&gt;% \n  mutate(On_street_name = str_to_title(On_street_name)) %&gt;% \n  count(On_street_name, sort = TRUE, name = \"Crashes\") %&gt;% \n  head(n=50)\n\n\n\nTable 5: Street with most crashes citywide"
  },
  {
    "objectID": "posts/2024-05-04-NYC-Crashes/index.html#footnotes",
    "href": "posts/2024-05-04-NYC-Crashes/index.html#footnotes",
    "title": "NYC Crash Data",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nIn general, vroom::vroom() is much faster than read.csv(), but here we’re also limited by connection speed; it took a little over a minute to read the data in with this approach.↩︎\nThere are a number of approaches for dealing with very large (and larger-than-memory) data sets, which I hope to cover in future posts.↩︎\nObligatory reference to that one Joy Division album cover.↩︎"
  },
  {
    "objectID": "posts/2024-11-25-ggplot-workshop/index.html",
    "href": "posts/2024-11-25-ggplot-workshop/index.html",
    "title": "Data Visualization with ggplot2",
    "section": "",
    "text": "Today’s post is adapted from a workshop I ran as part of my stats fellowship in my PhD program. My goal with this post is to cover the basics of data visualization with ggplot2 (natch), but also to shed a little light on the reasoning behind effective data communication.\nIn this post, we’ll cover the basics of ggplot2, then explore how to plot distributions and summary statistics, combine different representations of data in a single plot, customize plot appearance, and export plots.\nggplot2 implements a “grammar of graphics” (Wilkinson, 2005), allowing for the specification of plots in terms of individual elements, and the iterative creation of plots (we can layer elements in one by one). At heart, plots in ggplot2 consist of data (variables) mapped to aesthetics (e.g., position, color, and shape of plot elements).\n\n\nWe’ll be working with a simulated data set today (data-viz.csv); you can download it here. All the packages we’ll need can be loaded via library(tidyverse):\n\n# Load packages\nlibrary(tidyverse) \n\n# Load data\nmain_dat &lt;- read_csv(\"data-viz.csv\") \n\n# Overview of data\nsummary(main_dat)\n\n       ID          Condition            Gender             Major          \n Min.   :  1.00   Length:300         Length:300         Length:300        \n 1st Qu.: 75.75   Class :character   Class :character   Class :character  \n Median :150.50   Mode  :character   Mode  :character   Mode  :character  \n Mean   :150.50                                                           \n 3rd Qu.:225.25                                                           \n Max.   :300.00                                                           \n      SES           Anxiety            RT       \n Min.   :1.000   Min.   : 6.00   Min.   :112.0  \n 1st Qu.:2.000   1st Qu.:13.00   1st Qu.:180.8  \n Median :3.000   Median :16.00   Median :201.0  \n Mean   :2.637   Mean   :15.71   Mean   :200.7  \n 3rd Qu.:3.000   3rd Qu.:18.00   3rd Qu.:222.0  \n Max.   :5.000   Max.   :24.00   Max.   :279.0  \n\nglimpse(main_dat)\n\nRows: 300\nColumns: 7\n$ ID        &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 1…\n$ Condition &lt;chr&gt; \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", …\n$ Gender    &lt;chr&gt; \"Male\", \"Male\", \"Male\", \"Male\", \"Female\", \"Male\", \"Male\", \"M…\n$ Major     &lt;chr&gt; \"Psyc\", \"Hist\", \"Psyc\", \"Chem\", \"Hist\", \"Hist\", \"Hist\", \"Psy…\n$ SES       &lt;dbl&gt; 4, 3, 4, 1, 1, 1, 3, 3, 2, 2, 3, 2, 1, 1, 3, 5, 3, 2, 2, 1, …\n$ Anxiety   &lt;dbl&gt; 17, 14, 16, 17, 17, 19, 19, 17, 19, 17, 20, 15, 19, 16, 15, …\n$ RT        &lt;dbl&gt; 213, 151, 189, 240, 195, 187, 237, 178, 217, 179, 220, 182, …\n\n\nThe data is from an imaginary psychological experiment; we have three categorical variables (Condition, Major, and Gender) and three continuous variables (SES [socio-economic status], Anxiety, and RT [reaction time]) for each of 300 imaginary participants, each with a unique identifier (ID)."
  },
  {
    "objectID": "posts/2024-11-25-ggplot-workshop/index.html#load-data-set",
    "href": "posts/2024-11-25-ggplot-workshop/index.html#load-data-set",
    "title": "Data Visualization with ggplot2",
    "section": "",
    "text": "We’ll be working with a simulated data set today (data-viz.csv); you can download it here. All the packages we’ll need can be loaded via library(tidyverse):\n\n# Load packages\nlibrary(tidyverse) \n\n# Load data\nmain_dat &lt;- read_csv(\"data-viz.csv\") \n\n# Overview of data\nsummary(main_dat)\n\n       ID          Condition            Gender             Major          \n Min.   :  1.00   Length:300         Length:300         Length:300        \n 1st Qu.: 75.75   Class :character   Class :character   Class :character  \n Median :150.50   Mode  :character   Mode  :character   Mode  :character  \n Mean   :150.50                                                           \n 3rd Qu.:225.25                                                           \n Max.   :300.00                                                           \n      SES           Anxiety            RT       \n Min.   :1.000   Min.   : 6.00   Min.   :112.0  \n 1st Qu.:2.000   1st Qu.:13.00   1st Qu.:180.8  \n Median :3.000   Median :16.00   Median :201.0  \n Mean   :2.637   Mean   :15.71   Mean   :200.7  \n 3rd Qu.:3.000   3rd Qu.:18.00   3rd Qu.:222.0  \n Max.   :5.000   Max.   :24.00   Max.   :279.0  \n\nglimpse(main_dat)\n\nRows: 300\nColumns: 7\n$ ID        &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 1…\n$ Condition &lt;chr&gt; \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", …\n$ Gender    &lt;chr&gt; \"Male\", \"Male\", \"Male\", \"Male\", \"Female\", \"Male\", \"Male\", \"M…\n$ Major     &lt;chr&gt; \"Psyc\", \"Hist\", \"Psyc\", \"Chem\", \"Hist\", \"Hist\", \"Hist\", \"Psy…\n$ SES       &lt;dbl&gt; 4, 3, 4, 1, 1, 1, 3, 3, 2, 2, 3, 2, 1, 1, 3, 5, 3, 2, 2, 1, …\n$ Anxiety   &lt;dbl&gt; 17, 14, 16, 17, 17, 19, 19, 17, 19, 17, 20, 15, 19, 16, 15, …\n$ RT        &lt;dbl&gt; 213, 151, 189, 240, 195, 187, 237, 178, 217, 179, 220, 182, …\n\n\nThe data is from an imaginary psychological experiment; we have three categorical variables (Condition, Major, and Gender) and three continuous variables (SES [socio-economic status], Anxiety, and RT [reaction time]) for each of 300 imaginary participants, each with a unique identifier (ID)."
  },
  {
    "objectID": "posts/2024-11-25-ggplot-workshop/index.html#adding-plot-elements",
    "href": "posts/2024-11-25-ggplot-workshop/index.html#adding-plot-elements",
    "title": "Data Visualization with ggplot2",
    "section": "Adding plot elements",
    "text": "Adding plot elements\nHaving mapped variables onto the x-axis and y-axis, we can create a scatterplot by adding points via geom_point():\n\n# We'll omit argument names (data, mapping) going forward\n# ggplot() assumes the first argument is data and the second is mapping\nggplot(main_dat, aes(x = Anxiety, y= RT)) + geom_point() \n\n\n\n\n\n\n\n\ngeom_point() is an example of a geom, a geometric representation of data. We’ll see a number of different geoms later!\nNext, we can set the color of the points to be based on Condition by mapping it onto color in the original aes():\n\nggplot(main_dat, aes(x = Anxiety, y = RT, color = Condition)) + \n  geom_point()\n\n\n\n\n\n\n\n\nWe can map Major to the shape of the points in the same way:\n\nggplot(main_dat, aes(x = Anxiety, y = RT, color = Condition, shape = Major)) + \n  geom_point()\n\n\n\n\n\n\n\n\nEach addition to the aesthetic specification maps a new variable onto a new aesthetic of the plot. Also notice that we now get two legends, one for color and one for shape."
  },
  {
    "objectID": "posts/2024-11-25-ggplot-workshop/index.html#saving-plots",
    "href": "posts/2024-11-25-ggplot-workshop/index.html#saving-plots",
    "title": "Data Visualization with ggplot2",
    "section": "Saving plots",
    "text": "Saving plots\nTo save1 a plot for later use (and save ourselves a lot of copy-pasting), we can assign ggplot() output to an object:\n\nRT_by_anxiety_cond &lt;- ggplot(main_dat, aes(x = Anxiety, y = RT, \n                                           color = Condition, shape = Major)) + \n  geom_point()\n\nCalling the object then displays the plot:\n\nRT_by_anxiety_cond"
  },
  {
    "objectID": "posts/2024-11-25-ggplot-workshop/index.html#faceting",
    "href": "posts/2024-11-25-ggplot-workshop/index.html#faceting",
    "title": "Data Visualization with ggplot2",
    "section": "Faceting",
    "text": "Faceting\nWe now have four variables (Anxiety, RT, Condition, and Major) in one plot – very efficient, but a little hard to read. One solution is to split the plot into facets, giving us a mini-plot for each level of a factor…\n\nRT_by_anxiety_cond + facet_wrap(~Major) # \"By major\"\n\n\n\n\n\n\n\n\n…or for combinations of levels of factors:\n\nRT_by_anxiety_cond + facet_grid(Major~Condition) # \"By major and condition\"\n\n\n\n\n\n\n\n\nSwitch order of variables in facet_grid() to flip arrangement of facets:\n\nRT_by_anxiety_cond + facet_grid(Condition~Major) \n\n\n\n\n\n\n\n\nNotice that all of the facets have shared (aligned) axes, allowing us to compare data (e.g., point positions) between facets!\nfacet_grid() always creates rows and columns based on the faceting variable(s) you specify, which makes it useful when you want to facet by two specific variables. In contrast, facet_wrap() will wrap the facets into rows and columns, which makes it useful when you want to facet by a single variable that has more than three or so values:\n\n# New plot for this example\nggplot(main_dat, aes(x=Anxiety,y=RT)) + geom_point() + facet_wrap(~SES)\n\n\n\n\n\n\n\n\nNotice how SES levels 4 and 5 wrap around to make a second row!"
  },
  {
    "objectID": "posts/2024-11-25-ggplot-workshop/index.html#coordinates",
    "href": "posts/2024-11-25-ggplot-workshop/index.html#coordinates",
    "title": "Data Visualization with ggplot2",
    "section": "Coordinates",
    "text": "Coordinates\nWe can also customize the coordinate system used by our plot. Let’s force our y-axis includes zero:\n\n# To keep an auto-calculated limit, use NA\nRT_by_anxiety_cond + coord_cartesian(ylim = c(0,NA)) \n\n\n\n\n\n\n\n\nWe can swap X and Y axes using coord_flip():\n\nRT_by_anxiety_cond + coord_flip(ylim = c(0,NA)) # y-axis is now horizontal!\n\n\n\n\n\n\n\n\nOther useful coordinate systems:\n\ncoord_fixed() fixes aspect ratio of plot (good if X and Y are in same units)\ncoord_map()projects portion of globe onto 2D plane (good for maps!)"
  },
  {
    "objectID": "posts/2024-11-25-ggplot-workshop/index.html#theme",
    "href": "posts/2024-11-25-ggplot-workshop/index.html#theme",
    "title": "Data Visualization with ggplot2",
    "section": "Theme",
    "text": "Theme\nThemes allow us to change the appearance of the plot as a whole:\n\nRT_by_anxiety_cond + theme_light() # Use light background\n\n\n\n\n\n\n\nRT_by_anxiety_cond + theme_minimal() # Omit bounding boxes\n\n\n\n\n\n\n\nRT_by_anxiety_cond + theme_classic() # More traditional style\n\n\n\n\n\n\n\n\nWe can tweak the font2 used in the plot via arguments to the theme function:\n\nRT_by_anxiety_cond + theme_classic(base_size = 9, base_family = \"serif\") \n\n\n\n\n\n\n\n\nWe can manually customize further by adding an additional theme() function:\n\nRT_by_anxiety_cond + \n  theme(legend.position = \"bottom\") # Move legend to bottom\n\n\n\n\n\n\n\nRT_by_anxiety_cond + \n  facet_grid(Condition~Major) + \n  theme(legend.position = \"none\") # Remove unnecessary legends\n\n\n\n\n\n\n\n\nVirtually every aspect of the plot’s appearance can be customized via the theme() function, from major/minor axes to tick marks to the axis titles."
  },
  {
    "objectID": "posts/2024-11-25-ggplot-workshop/index.html#recap",
    "href": "posts/2024-11-25-ggplot-workshop/index.html#recap",
    "title": "Data Visualization with ggplot2",
    "section": "Recap",
    "text": "Recap\nLet’s pause and review how to construct a plot with ggplot():\n\nWe start by giving ggplot() a data frame (here, main_dat)\nWithin the aes() argument, we map variables to specific elements (x and y position, color, and shape)\nWe provide (at least one) geom to represent the data (here, geom_point() to get points)\nWe can facet by one (or more) variables to produce multiple plots with shared axes\nWe can specify coordinate systems (e.g., coord_flip())\nThemes let us customize overall plot appearance\n\nNext, we’ll explore how we can use these tools to visualize different types of data!"
  },
  {
    "objectID": "posts/2024-11-25-ggplot-workshop/index.html#histograms",
    "href": "posts/2024-11-25-ggplot-workshop/index.html#histograms",
    "title": "Data Visualization with ggplot2",
    "section": "Histograms",
    "text": "Histograms\nWe can make histograms with geom_histogram(). We don’t map anything to the y-axis – R automatically maps frequency.\n\nggplot(main_dat, aes(x = Anxiety)) + # No Y aesthetic!\n  geom_histogram()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\nWe can manually set size of bins:\n\nggplot(main_dat, aes(x = Anxiety)) + \n  geom_histogram(binwidth = 2)\n\n\n\n\n\n\n\n\nWhat if we want to look at the distribution separately for each level of Condition? We can map Condition onto the fill color of the histogram via the fill aesthetic3:\n\nggplot(main_dat, aes(x = Anxiety, fill = Condition)) +\n  geom_histogram(binwidth = 2)\n\n\n\n\n\n\n\n\nThis plot’s not great – it’s hard to read counts for Control and Treatment 1. Instead, let’s try faceting:\n\nggplot(main_dat, aes(x = Anxiety, fill = Condition)) + \n  geom_histogram(binwidth = 2) + \n  facet_wrap(~Condition, ncol = 1) + # Force facets into single column\n  theme(legend.position = \"none\") # Remove superfluous legend\n\n\n\n\n\n\n\n\nThis plot makes it much easier to compare distributions between the three groups – notice that x-axis (Anxiety) scores are aligned across all three facets."
  },
  {
    "objectID": "posts/2024-11-25-ggplot-workshop/index.html#bar-plot-of-frequencies",
    "href": "posts/2024-11-25-ggplot-workshop/index.html#bar-plot-of-frequencies",
    "title": "Data Visualization with ggplot2",
    "section": "Bar plot of frequencies",
    "text": "Bar plot of frequencies\nFor categorical variables (like Condition), we can get frequency as a bar plot using geom_bar(). Just like with histograms, we don’t map anything to the y-axis; the geom automatically calculates the height of the bars (in this case, by counting the number of cases).\n\nggplot(main_dat,aes(x = Gender)) + # No Y aesthetic!\n  geom_bar()"
  },
  {
    "objectID": "posts/2024-11-25-ggplot-workshop/index.html#background",
    "href": "posts/2024-11-25-ggplot-workshop/index.html#background",
    "title": "Data Visualization with ggplot2",
    "section": "Background",
    "text": "Background\nUnder the hood, all geometric elements have a stat that determines how the data translates into the properties of the geom:\n\ngeom_point(): x and y coordinates of points come directly from numeric values (identity)\ngeom_histogram(): height of bin comes from number of values in bin (count)\ngeom_bar(): height of bar comes from number of values in category (count)\n\ngeom_point() creates one object for each data point, while geom_histogram() and geom_bar() use a built-in summary statistic. Sometimes, we’ll want to tweak this process (e.g., if we want to plot a different summary statistic):\n\nBarplot: height of bar from the mean of each group\nPointrange: height of point from mean of group, width of range from variability of group\n\nThere are two possible approaches here:\n\nCalculate summary statistics for each group, then plot these values\n\ndata %&gt;% group_by() %&gt;% summarize() %&gt;% ggplot()\n\nHave ggplot generate specific summary statistics for us\n\ndata %&gt;% ggplot() + stat_summary()\n\n\nToday, we’ll focus on the second approach!"
  },
  {
    "objectID": "posts/2024-11-25-ggplot-workshop/index.html#getting-summary-statistics-on-the-fly",
    "href": "posts/2024-11-25-ggplot-workshop/index.html#getting-summary-statistics-on-the-fly",
    "title": "Data Visualization with ggplot2",
    "section": "Getting summary statistics on the fly",
    "text": "Getting summary statistics on the fly\nLet’s get a bar plot in which the bar heights represent group means (rather than frequencies):\n\nggplot(main_dat, aes(x = Condition, y = Anxiety)) + \n  stat_summary(fun = \"mean\", geom = \"bar\") # Get the mean, represent via bars\n\n\n\n\n\n\n\n\nIf we want to get fancy, we can specify summary functions that return multiple values for each group, and geoms that use all these values:\n\nggplot(main_dat, aes(x = Condition, y = Anxiety)) + \n  stat_summary(fun.data = \"mean_cl_normal\", geom = \"pointrange\")\n\n\n\n\n\n\n\n\nWe use fun.data because the function we’ve specified (mean_cl_normal) returns a data frame consisting of the mean as well as the upper and lower bounds of the 95% confidence interval."
  },
  {
    "objectID": "posts/2024-11-25-ggplot-workshop/index.html#multiple-2-geoms",
    "href": "posts/2024-11-25-ggplot-workshop/index.html#multiple-2-geoms",
    "title": "Data Visualization with ggplot2",
    "section": "2 Multiple 2 Geoms",
    "text": "2 Multiple 2 Geoms\nWe can have more than one geom in the same plot! Let’s add a line:\n\nggplot(main_dat, aes(x = Condition, y = Anxiety)) + \n  # Plot means as line, all one group\n  stat_summary(fun = \"mean\", geom = \"line\", group = 1) +\n  # Plot means/CIs as pointranges\n  stat_summary(fun.data = \"mean_cl_normal\", geom = \"pointrange\")\n\n\n\n\n\n\n\n\nNotice the line uses fun (instead of fun.data) because it represents a single summary statistic (the mean).\nWe can combine summary statistics (our pointrange and lines) with raw data (i.e., individual data points):\n\nggplot(main_dat, aes(x = Condition, y = Anxiety)) + \n  stat_summary(fun.data = \"mean_cl_normal\", geom = \"pointrange\") + \n  stat_summary(fun = \"mean\", geom = \"line\", group = 1) +\n  geom_point() # Add in raw data\n\n\n\n\n\n\n\n\nTo avoid overplotting (data points directly on top of each other), we can make the points partially transparent:\n\nggplot(main_dat, aes(x = Condition, y = Anxiety)) + \n  stat_summary(fun.data = \"mean_cl_normal\", geom = \"pointrange\") + \n  stat_summary(fun = \"mean\", geom = \"line\", group = 1) + \n  geom_point(alpha = .1) # 1 = opaque, 0 = fully transparent\n\n\n\n\n\n\n\n\nWe can also use a different geom to summarize the data:\n\nggplot(main_dat, aes(x = Condition, y = Anxiety)) + \n  geom_violin() + # Put first so pointranges/lines are drawn on top\n  stat_summary(fun.data = \"mean_cl_normal\", geom = \"pointrange\") + \n  stat_summary(fun = \"mean\", geom = \"line\", group = 1)"
  },
  {
    "objectID": "posts/2024-11-25-ggplot-workshop/index.html#multiple-pointranges-multiple-lines",
    "href": "posts/2024-11-25-ggplot-workshop/index.html#multiple-pointranges-multiple-lines",
    "title": "Data Visualization with ggplot2",
    "section": "Multiple pointranges, multiple lines",
    "text": "Multiple pointranges, multiple lines\nLet’s break things down by major as well as condition!\n\nmain_dat %&gt;% \n  ggplot(aes(x = Condition, y = Anxiety, \n             color = Major, group = Major)) + # Specify how to group!\n  stat_summary(fun.data = \"mean_cl_normal\", geom = \"pointrange\") + \n  stat_summary(fun = \"mean\", geom = \"line\") + \n  geom_point(alpha = .1)\n\n\n\n\n\n\n\n\nTo make things easier to read, let’s dodge the geoms for each group (i.e., shift them slightly left/right so they’re not stacked atop each other):\n\nmain_dat %&gt;% \n  ggplot(aes(x = Condition, y = Anxiety, color = Major, group = Major)) + \n  stat_summary(fun.data = \"mean_cl_normal\", \n               geom = \"pointrange\", \n               position = position_dodge(width = .5)) + \n  stat_summary(fun = \"mean\", \n               geom = \"line\",\n               position = position_dodge(width = .5)) +\n  geom_point(alpha = .1, position = position_dodge(width = .5))\n\n\n\n\n\n\n\n\nNote that we need to specify dodge for each geom to keep things aligned!\nLet’s save this plot for later use:\n\nAnxiety_by_cond_major &lt;- main_dat %&gt;% \n  ggplot(aes(x = Condition, y = Anxiety, color = Major, group = Major)) + \n  stat_summary(fun.data = \"mean_cl_normal\", \n               geom = \"pointrange\", \n               position = position_dodge(width = .5)) + \n  stat_summary(fun = \"mean\", \n               geom = \"line\",\n               position = position_dodge(width = .5)) +\n  geom_point(alpha = .1, position = position_dodge(width = .5))\n\nNotice how we were able to build this (fairly complex) plot incrementally: we started by mapping Condition and Anxiety to the x and y axes, selected appropriate geoms to display our data (both summary statistics via stat_summary() and raw values via geom_point()), added another variable (Major) mapped onto color, and finally tweaked the geoms’ position to avoid overplotting. This process aligns nicely with how I tend to approach data visualization: I start by thinking about what variables I want to plot, then figure out how to display them via reckless experimentation."
  },
  {
    "objectID": "posts/2024-11-25-ggplot-workshop/index.html#changing-labels",
    "href": "posts/2024-11-25-ggplot-workshop/index.html#changing-labels",
    "title": "Data Visualization with ggplot2",
    "section": "Changing labels",
    "text": "Changing labels\nWe can set labels within scale_*() functions, or by using the convenience function labs(). Let’s try this with our earlier scatterplot:\n\nRT_by_anxiety_cond + # Back to our scatterplot!\n  labs(title = \"Mean reaction time by anxiety score, condition, and major\", \n       subtitle = \"Check out my awesome subtitle!\",\n       caption = \"Can note exclusion criteria, define error bars, etc.\",\n       x = \"Anxiety score\", # List of scales and names\n       y = \"Mean reaction time (ms)\")\n\n\n\n\n\n\n\n\nNote that all of the labels display within the plot area, and are distinct from figure captions that may be generated by (e.g.) RMarkdown or Quarto. In some contexts, it may be helpful to put as much information as possible in the plot itself (e.g., for a presentation or conference poster), while in other contexts this information may be displayed in the figure caption instead (e.g., a journal article). Here’s what this same figure might look like if we took the second approach:\n\nRT_by_anxiety_cond + \n  labs(x = \"Anxiety score\", # List of scales and names\n       y = \"Mean reaction time (ms)\")\n\n\n\n\n\n\n\nFigure 1: Mean reaction time by anxiety score, condition, and major. Check out my awesome subtitle! Here’s some information about exclusion criteria, error bars, etc."
  },
  {
    "objectID": "posts/2024-11-25-ggplot-workshop/index.html#customizing-continuous-axes",
    "href": "posts/2024-11-25-ggplot-workshop/index.html#customizing-continuous-axes",
    "title": "Data Visualization with ggplot2",
    "section": "Customizing continuous axes",
    "text": "Customizing continuous axes\nWe can add arguments to scale_*() functions to customize the upper/lower bounds, and to determine where the breaks fall:\n\nRT_by_anxiety_cond +\n  scale_y_continuous(name = \"Mean reaction time (ms)\", # Another way to label!\n                     limits = c(0,300), # Upper and lower bounds\n                     breaks = 0:6*50)  # Should give vector of break points\n\n\n\n\n\n\n\n\nIf your limits clip some of your data, you’ll get a warning:\n\nRT_by_anxiety_cond +\n  scale_y_continuous(name = \"Mean reaction time (ms)\",\n                     limits = c(0,200), # Clips off upper end of data range\n                     breaks = 0:6*50)\n\nWarning: Removed 151 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\nIf you are calculating summary statistics via stat_summary(), data that gets clipped off won’t be included in summary statistics, which can skew results. It’s a good idea to set the “window” via coord instead:\n\nRT_by_anxiety_cond + \n  coord_cartesian(ylim = c(0,200))"
  },
  {
    "objectID": "posts/2024-11-25-ggplot-workshop/index.html#customizing-discrete-axes",
    "href": "posts/2024-11-25-ggplot-workshop/index.html#customizing-discrete-axes",
    "title": "Data Visualization with ggplot2",
    "section": "Customizing discrete axes",
    "text": "Customizing discrete axes\nWe can manually relabel levels of our discrete (categorical) x-axis. Let’s try on our pointrange plot:\n\nAnxiety_by_cond_major + # Our pointrange plot\n  scale_x_discrete(labels = c(\"0mg\", \"500mg\", \"1000mg\")) # Applied in order\n\n\n\n\n\n\n\n\nIn general, to relabel levels, tweak the scale that produced them. Here, for our scatterplot, we’ll relabel Condition (mapped onto color) and Major (mapped onto shape):\n\nRT_by_anxiety_cond + # Our scatterplot\n  scale_color_discrete(labels = c(\"0mg\", \"500mg\", \"1000mg\")) +\n  scale_shape_discrete(labels = c(\"Chemistry\",\"History\",\"Psychology\"))"
  },
  {
    "objectID": "posts/2024-11-25-ggplot-workshop/index.html#adjusting-colors",
    "href": "posts/2024-11-25-ggplot-workshop/index.html#adjusting-colors",
    "title": "Data Visualization with ggplot2",
    "section": "Adjusting colors",
    "text": "Adjusting colors\nWe can change the palettes R uses for colors. Let’s practice with a brand-new plot:\n\n# Create bar plot of gender frequency\nGender_plot &lt;- ggplot(main_dat, aes(x = Gender, fill = Gender)) + \n  geom_bar()\n\n# Default palette\nGender_plot\n\n\n\n\n\n\n\n# Greyscale\nGender_plot + scale_fill_grey()\n\n\n\n\n\n\n\n# Brewer\nGender_plot + scale_fill_brewer(type = \"qual\", # Qualitative palettes\n                                palette = \"Set2\") # Specific palette\n\n\n\n\n\n\n\n\nWe can also manually specify colors via scale_fill_manual(), either by name:\n\nGender_plot + \n  scale_fill_manual(values =c(\"darkorange\", \"dodgerblue\", \"green\", \"purple\"))\n\n\n\n\n\n\n\n\nOr by hex code (useful to match existing palettes such as school or corporate color schemes):\n\nGender_plot +\n  scale_fill_manual(values =c(\"#003660\", \"#FEBC11\", \"#043927\", \"#c4b581\"))\n\n\n\n\n\n\n\n\nFor ordinal variables (like SES), might make sense to use a sequential palette:\n\nggplot(main_dat, aes(x = SES, fill = factor(SES))) + # Make R treat as factor\n  geom_bar() +\n  scale_fill_brewer(type = \"seq\") # Sequential palette\n\n\n\n\n\n\n\n\nIf a factor is ordered, ggplot automatically uses scale_viridis (an excellent sequential palette):\n\n# Distribution of SES\nggplot(main_dat, aes(x = SES, fill = ordered(SES))) + \n  geom_bar()\n\n\n\n\n\n\n\n# Distribution of SES by condition\nggplot(main_dat, aes(x = Condition, fill = ordered(SES))) +\n  geom_bar()\n\n\n\n\n\n\n\n\nNotice that for all of these examples except the last, color is just for visual appeal; it doesn’t add information to the plot beyond what’s already communicated by the bars themselves. When color does convey information, it’s important to consider accessibility (e.g., whether the plot can still convey information effectively to viewers with colorblindness). Some options include using another aesthetic as a fallback (e.g., mapping the variable onto shape as well as color), faceting the plot, using a colorblind-friendly palette (such as scale_viridis)4."
  },
  {
    "objectID": "posts/2024-11-25-ggplot-workshop/index.html#more-ggplot2-resources",
    "href": "posts/2024-11-25-ggplot-workshop/index.html#more-ggplot2-resources",
    "title": "Data Visualization with ggplot2",
    "section": "More ggplot2 resources",
    "text": "More ggplot2 resources\n\nOfficial ggplot2 reference: First stop for specifics of ggplot2 functions!\nR Graphics Cookbook (2e): Great for anytime you ask yourself “How the heck do I do X”?\nggplot2: elegant graphics for data analysis: For when you’re ready to go deeper!\nFundamentals of Data Visualization: For big-picture questions about data visualization and communication best practices!"
  },
  {
    "objectID": "posts/2024-11-25-ggplot-workshop/index.html#footnotes",
    "href": "posts/2024-11-25-ggplot-workshop/index.html#footnotes",
    "title": "Data Visualization with ggplot2",
    "section": "Footnotes",
    "text": "Footnotes\n\n\n“Save” here means “keep in memory”, not “save to disk”; we’ll cover that a little later.↩︎\nUsing custom fonts in ggplot2 is tricky, to say the least. The three options guaranteed to work on any graphic device are sans (the default), serif, and mono; anything else is a roll of the dice. I hope to cover this topic in a little more detail in a future post, since I’ve spent a good amount of time tearing my hair out over it.↩︎\nFor geoms that don’t have an “interior” (e.g., points and lines), the color aesthetic sets the color of the whole geom. For geoms that do have an interior (e.g., histograms and bars), the fill aesthetic sets the interior color and the color aesthetic sets the outline color. It can be a little tricky to remember – if specifying one aesthetic doesn’t work the way you expect, try specifying the other and see if that has the desired effect.↩︎\nDisclaimer: I am not an expert in accessibility, and cannot guarantee that these tips will make plots fully or even partially compliant with regulation regarding accessibility (e.g., the ADA). Please don’t sue me!↩︎"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About Me",
    "section": "",
    "text": "I am an unapologetic data nerd with a passion for turning messy data into understandable, actionable insights. I have tackled projects ranging from investigations of the cognitive mechanisms of ingroup bias, to explorations of gender differences in science education programs for elementary schools, to assessments of learning outcomes in leadership development workshops for state employees. I have substantial experience with framing research questions, developing and implementing appropriate methods (experimental and/or survey-based designs), assessing and aligning existing data sources, conducting statistical analyses, and communicating findings to stakeholders via reports, dashboards, and more."
  },
  {
    "objectID": "about.html#skills",
    "href": "about.html#skills",
    "title": "About Me",
    "section": "Skills",
    "text": "Skills\nMy skills include:\n\nExperimental design\nSurvey development\nData aggregation, cleaning, and analysis\nData visualization and communication\nReproducible analysis and reporting workflows\nTeaching/tutoring statistical methods and research best practices\nR + tidyverse + Quarto, Git + GitHub, SQL, Python, SPSS, LaTeX, Qualtrics"
  },
  {
    "objectID": "about.html#education",
    "href": "about.html#education",
    "title": "About Me",
    "section": "Education",
    "text": "Education\n\nUniversity of California, Santa Barbara\nPh.D. in Psychological and Brain Sciences, June 2022\n\nEmphasis in Quantitative Methods in Social Science (QMSS)\nCertificate in College and University Teaching (CCUT)\n\n\n\nCalifornia State University, Sacramento\nM.A. in Psychology, May 2016\n\n\nOccidental College\nB.A. in Psychology, May 2011\n\nMinor in Mathematics"
  }
]